# Optimization Patterns
* 放弃单独分配和释放对象，从固定的池子中重用对象，提高性能和内存的使用率

``` mermaid
flowchart TD;
1(堆初始为空) --> 2[分配对象 'foo' 7个字节];

2 --> 3[分配对象 bar 12个字节];
3 --> 4[删除 'foo' 堆被切成两段];
4 --> 5[再次分配一个bar 哪里都塞不进去]
?
foo:7?;
foo:7bar:12?;
?bar:12?;
bar:12 --> ?bar:12?;
```
## 模式
* 定义一组池对象，包含一组可以重用的对象，每个可以重用的对象都可以查询"使用中"状态，说明它是否在使用中。池在被初始化的时候，就创建了整个对象的集合(通常使用一阵个连续的呃分配)，然后初始化所有的状态"不在使用中"。
* 需要对象时，向池子要一个，池子找到一个可用的对象，初始化为使用中然后返回。当对象不被需要了，就设置回"不在使用中"。

## 使用时机
* 需要频繁创建销毁对象
* 对象大小差不多
* 在堆上进行对象内存分配十分缓慢，或者回导致内存碎片
* 每个对象都封装了数据库或者网络连接这种昂贵的可以重用的资源

## 管理池
* 当对象大小相同时使用数组管理
* 当对象大小差距太大时，分池管理
* 分池管理的管理者有一系列的池，池的每个块的大小不同，当申请分配一块的时候，从合适的块的大小池分配。

``` mermaid
classDiagram
%% 本类不再被使用
class Particle
Particle : -int framLeft_
Particle : -double x_
Particle : -double y_
Particle : -double xVel_
Particle : -double yVel_
Particle : +init(double x, double y, double xVel_, yVel_)
Particle : +animate()
Particle : +inUse() bool
Particle : +Particle()

class ParticlePool {
    static const -int POOL_SIZE 
    -Particle_v2 particles[POOL_SIZE]
    -Particle_v2* firstAvailable

    +create(double x, double y, double xVel, double yVel)
    +animate()
}

class Particle_v2 {
    friend clas ParticlePool
   -int framesLeft
   -union state_
   -struct live
   state_ contain live
   getNext() Particle*
   setNext(Particle* next)
   inUse_() bool
   Particle() : inUse_(false)
}

class live {
    double x
    double y
    double xVel
    double yVel
}

class state_ {
    struct live
    Particle* next
}

```