# Optimization Patterns
* 放弃单独分配和释放对象，从固定的池子中重用对象，提高性能和内存的使用率

``` mermaid
flowchart TD;
1(堆初始为空) --> 2[分配对象 'foo' 7个字节];

2 --> 3[分配对象 bar 12个字节];
3 --> 4[删除 'foo' 堆被切成两段];
4 --> 5[再次分配一个bar 哪里都塞不进去]
?
foo:7?;
foo:7bar:12?;
?bar:12?;
bar:12 --> ?bar:12?;
```
## 模式
* 定义一组池对象，包含一组可以重用的对象，每个可以重用的对象都可以查询"使用中"状态，说明它是否在使用中。池在被初始化的时候，就创建了整个对象的集合(通常使用一阵个连续的呃分配)，然后初始化所有的状态"不在使用中"。
* 需要对象时，向池子要一个，池子找到一个可用的对象，初始化为使用中然后返回。当对象不被需要了，就设置回"不在使用中"。

## 使用时机
* 需要频繁创建销毁对象
* 对象大小差不多
* 在堆上进行对象内存分配十分缓慢，或者回导致内存碎片
* 每个对象都封装了数据库或者网络连接这种昂贵的可以重用的资源

## 管理池
* 当对象大小相同时使用数组管理
* 当对象大小差距太大时，分池管理
* 分池管理的管理者有一系列的池，池的每个块的大小不同，当申请分配一块的时候，从合适的块的大小池分配。

``` mermaid
classDiagram
%% 本类不再被使用
class Particle
Particle : -int framLeft_
Particle : -double x_
Particle : -double y_
Particle : -double xVel_
Particle : -double yVel_
Particle : +init(double x, double y, double xVel_, yVel_)
Particle : +animate()
Particle : +inUse() bool
Particle : +Particle()
Particle -- "该类不再被使用已升级为Particle v2" Destroy
class ParticlePool {
    static const -int POOL_SIZE 
    -Particle_v2 particles[POOL_SIZE]
    -Particle_v2* firstAvailable

    +create(double x, double y, double xVel, double yVel)
    +animate()
}

class Particle_v2 {
    friend clas ParticlePool
   -int framesLeft
   -union state_
   -struct live
   state_ contain live
   getNext() Particle*
   setNext(Particle* next)
   inUse_() bool
   Particle() : inUse_(false)
}

class live {
    double x
    double y
    double xVel
    double yVel
}

class state_ {
    struct live
    Particle* next
}

```

* 对象池类设计
``` mermaid
classDiagram
class ObjectPool {
    +GameObject objectPrefab
    -Queue~GameObject~ _objectPool
    -int _poolInitNum

    +InitPool() // 初始化对象池
    +GetBullet() GameObject //从对象池获取对象
    +RecycleBullet(GameObject bullet) // 回收对象到对象池

}
MonoBehaviour <|-- ObjectPool
MonoBehaviour <|-- MyObject
class MyObject {
    +ObjectPool pool
    +float aliveTime
    -flaot _countDownCD
    -Sequence _sequence
    +Animate()
    -OnEnable()
    -OnDisable()
    -Update()
    -TimeOut()
}
MyObject ..> ObjectPool

class ObjectManager {
    +ObjectPool pool
    -Start()
    -Update()
}

ObjectManager --|> MonoBehaviour
ObjectManager ..> ObjectPool
```

* 各个方向流程
* InitPool GetBullet RecycleBullet
``` mermaid
flowchart LR
InitPool
_objectPool初始化对象池队列 --> object临时变量存放对象初始为null --> i初始化0
--> i{i < _poolInitNum} -- yes --> 初始化预制体赋值object --> object.pool赋值this
--> objectSetActive为false-->对象池入队object到_objectPool.Enqueue-->i++-->i
i -- no --> End

GetBullet
A{_objectPool.Count>0 && _bocjetPool is not null} -- yes --> B[_objectPool.Dequeue to bullet] --> C[bullet.SetActive for true] --> D[return bullet]
A -- no --> 5[return 初始化一个预制体作为新对象]

RecycleBullet
1[bullet.SetActive for false] --> 2[_objctPool.Enqueue to bullet]

```